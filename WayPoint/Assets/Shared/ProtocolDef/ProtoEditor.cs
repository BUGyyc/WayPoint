// Generated by ProtoGen, Version=2.4.1.555, Culture=neutral, PublicKeyToken=17b3b1f090c3ea48.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace Protocol {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class ProtoEditor {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_Protocol_WayMapCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.WayMapCfg, global::Protocol.WayMapCfg.Builder> internal__static_Protocol_WayMapCfg__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_WayPointCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.WayPointCfg, global::Protocol.WayPointCfg.Builder> internal__static_Protocol_WayPointCfg__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_WayLineCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.WayLineCfg, global::Protocol.WayLineCfg.Builder> internal__static_Protocol_WayLineCfg__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_Float3__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.Float3, global::Protocol.Float3.Builder> internal__static_Protocol_Float3__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static ProtoEditor() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChJwcm90b19lZGl0b3IucHJvdG8SCFByb3RvY29sImYKCVdheU1hcENmZxIt", 
            "CgZwb2ludHMYASADKAsyFS5Qcm90b2NvbC5XYXlQb2ludENmZ1IGcG9pbnRz", 
            "EioKBWxpbmVzGAIgAygLMhQuUHJvdG9jb2wuV2F5TGluZUNmZ1IFbGluZXMi", 
            "8gIKC1dheVBvaW50Q2ZnEg4KAmlkGAEgAigNUgJpZBIUCgVtYXBJZBgCIAIo", 
            "DVIFbWFwSWQSLAoIcG9zaXRpb24YAyACKAsyEC5Qcm90b2NvbC5GbG9hdDNS", 
            "CHBvc2l0aW9uEioKB2ZvcndhcmQYBCABKAsyEC5Qcm90b2NvbC5GbG9hdDNS", 
            "B2ZvcndhcmQSIgoMbWluU3RhbmRUaW1lGAUgASgCUgxtaW5TdGFuZFRpbWUS", 
            "IgoMbWF4U3RhbmRUaW1lGAYgASgCUgxtYXhTdGFuZFRpbWUSEgoEdHlwZRgH", 
            "IAEoDVIEdHlwZRIdCgpsaW5lX2NvdW50GAggASgNUglsaW5lQ291bnQSJAoO", 
            "cGFzc19saW5lX3RpbWUYCSABKAJSDHBhc3NMaW5lVGltZRIfCgtuZWVkX29m", 
            "ZnNldBgKIAEoCFIKbmVlZE9mZnNldBIhCgxvZmZzZXRfdmFsdWUYCyABKAJS", 
            "C29mZnNldFZhbHVlIpQBCgpXYXlMaW5lQ2ZnEikKBGhlYWQYASACKAsyFS5Q", 
            "cm90b2NvbC5XYXlQb2ludENmZ1IEaGVhZBIpCgRsYXN0GAIgAigLMhUuUHJv", 
            "dG9jb2wuV2F5UG9pbnRDZmdSBGxhc3QSEgoEY29zdBgDIAIoAlIEY29zdBIc", 
            "Cgppc19vbmVfd2F5GAQgAigIUghpc09uZVdheSIyCgZGbG9hdDMSDAoBeBgB", 
          "IAEoAlIBeBIMCgF5GAIgASgCUgF5EgwKAXoYAyABKAJSAXo="));
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_Protocol_WayMapCfg__Descriptor = Descriptor.MessageTypes[0];
        internal__static_Protocol_WayMapCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.WayMapCfg, global::Protocol.WayMapCfg.Builder>(internal__static_Protocol_WayMapCfg__Descriptor,
                new string[] { "Points", "Lines", });
        internal__static_Protocol_WayPointCfg__Descriptor = Descriptor.MessageTypes[1];
        internal__static_Protocol_WayPointCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.WayPointCfg, global::Protocol.WayPointCfg.Builder>(internal__static_Protocol_WayPointCfg__Descriptor,
                new string[] { "Id", "MapId", "Position", "Forward", "MinStandTime", "MaxStandTime", "Type", "LineCount", "PassLineTime", "NeedOffset", "OffsetValue", });
        internal__static_Protocol_WayLineCfg__Descriptor = Descriptor.MessageTypes[2];
        internal__static_Protocol_WayLineCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.WayLineCfg, global::Protocol.WayLineCfg.Builder>(internal__static_Protocol_WayLineCfg__Descriptor,
                new string[] { "Head", "Last", "Cost", "IsOneWay", });
        internal__static_Protocol_Float3__Descriptor = Descriptor.MessageTypes[3];
        internal__static_Protocol_Float3__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.Float3, global::Protocol.Float3.Builder>(internal__static_Protocol_Float3__Descriptor,
                new string[] { "X", "Y", "Z", });
        pb::ExtensionRegistry registry = pb::ExtensionRegistry.CreateInstance();
        RegisterAllExtensions(registry);
        return registry;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          }, assigner);
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class WayMapCfg : pb::GeneratedMessage<WayMapCfg, WayMapCfg.Builder> {
    public WayMapCfg() { }
    private static readonly WayMapCfg defaultInstance = new WayMapCfg().MakeReadOnly();
    private static readonly string[] _wayMapCfgFieldNames = new string[] { "lines", "points" };
    private static readonly uint[] _wayMapCfgFieldTags = new uint[] { 18, 10 };
    public static WayMapCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override WayMapCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override WayMapCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_WayMapCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<WayMapCfg, WayMapCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_WayMapCfg__FieldAccessorTable; }
    }
    
    public const int PointsFieldNumber = 1;
    private pbc::PopsicleList<global::Protocol.WayPointCfg> points_ = new pbc::PopsicleList<global::Protocol.WayPointCfg>();
    public scg::IList<global::Protocol.WayPointCfg> Points {
      get { return pbc::Lists.AsReadOnly(points_); }
    }
    public int PointsCount {
      get { return points_.Count; }
    }
    public global::Protocol.WayPointCfg GetPoints(int index) {
      return points_[index];
    }
    public global::Protocol.WayPointCfg FindPoints(System.Predicate<global::Protocol.WayPointCfg> match) {
      return points_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.WayPointCfg> FindAllPoints(System.Predicate<global::Protocol.WayPointCfg> match) {
      return points_.FindAll(match);
    }
    public void SetPoints(int index, global::Protocol.WayPointCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= points_.Count) return;
      points_[index] = value;
    }
    public void AddPoints(global::Protocol.WayPointCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      points_.Add(value);
    }
    public void AddRangePoints(scg::IEnumerable<global::Protocol.WayPointCfg> values) {
      points_.Add(values);
    }
    public void RemovePoints(global::Protocol.WayPointCfg value) {
      if (!points_.Contains(value)) return;
      points_.Remove(value);
    }
    public void RemoveAtPoints(int index) {
      if (index < 0 || index >= points_.Count) return;
      points_.RemoveAt(index);
    }
    public void ClearPoints() {
      if (points_.Count <= 0) return;
      points_.Clear();
    }
    
    public const int LinesFieldNumber = 2;
    private pbc::PopsicleList<global::Protocol.WayLineCfg> lines_ = new pbc::PopsicleList<global::Protocol.WayLineCfg>();
    public scg::IList<global::Protocol.WayLineCfg> Lines {
      get { return pbc::Lists.AsReadOnly(lines_); }
    }
    public int LinesCount {
      get { return lines_.Count; }
    }
    public global::Protocol.WayLineCfg GetLines(int index) {
      return lines_[index];
    }
    public global::Protocol.WayLineCfg FindLines(System.Predicate<global::Protocol.WayLineCfg> match) {
      return lines_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.WayLineCfg> FindAllLines(System.Predicate<global::Protocol.WayLineCfg> match) {
      return lines_.FindAll(match);
    }
    public void SetLines(int index, global::Protocol.WayLineCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= lines_.Count) return;
      lines_[index] = value;
    }
    public void AddLines(global::Protocol.WayLineCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      lines_.Add(value);
    }
    public void AddRangeLines(scg::IEnumerable<global::Protocol.WayLineCfg> values) {
      lines_.Add(values);
    }
    public void RemoveLines(global::Protocol.WayLineCfg value) {
      if (!lines_.Contains(value)) return;
      lines_.Remove(value);
    }
    public void RemoveAtLines(int index) {
      if (index < 0 || index >= lines_.Count) return;
      lines_.RemoveAt(index);
    }
    public void ClearLines() {
      if (lines_.Count <= 0) return;
      lines_.Clear();
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Protocol.WayPointCfg element in Points) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::Protocol.WayLineCfg element in Lines) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _wayMapCfgFieldNames;
      if (points_.Count > 0) {
        output.WriteMessageArray(1, field_names[1], points_);
      }
      if (lines_.Count > 0) {
        output.WriteMessageArray(2, field_names[0], lines_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      foreach (global::Protocol.WayPointCfg element in Points) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, element);
      }
      foreach (global::Protocol.WayLineCfg element in Lines) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public WayMapCfg CommitChange() {
      WayMapCfg other = new WayMapCfg();
      bool isChange = false;
      isChange = true;
      other.points_.Add(points_);
      isChange = true;
      other.lines_.Add(lines_);
      return isChange?other:null;
    }
    
    public void MergeFrom(WayMapCfg other, bool isFull = false) {
      if (other == global::Protocol.WayMapCfg.DefaultInstance) return;
        points_.Clear();
        points_.Add(other.points_);
        lines_.Clear();
        lines_.Add(other.lines_);
    }
    
    public static WayMapCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static WayMapCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static WayMapCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static WayMapCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static WayMapCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static WayMapCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static WayMapCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static WayMapCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static WayMapCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static WayMapCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private WayMapCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(WayMapCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<WayMapCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(WayMapCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private WayMapCfg result;
      
      private WayMapCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          WayMapCfg original = result;
          result = new WayMapCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override WayMapCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.WayMapCfg.Descriptor; }
      }
      
      public override WayMapCfg DefaultInstanceForType {
        get { return global::Protocol.WayMapCfg.DefaultInstance; }
      }
      
      public override WayMapCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is WayMapCfg) {
          return MergeFrom((WayMapCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(WayMapCfg other) {
        if (other == global::Protocol.WayMapCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.points_.Count != 0) {
          result.points_.Add(other.points_);
        }
        if (other.lines_.Count != 0) {
          result.lines_.Add(other.lines_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_wayMapCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _wayMapCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.points_, global::Protocol.WayPointCfg.DefaultInstance, extensionRegistry);
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.lines_, global::Protocol.WayLineCfg.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::Protocol.WayPointCfg> Points {
        get { return PrepareBuilder().points_; }
      }
      public int PointsCount {
        get { return result.PointsCount; }
      }
      public global::Protocol.WayPointCfg GetPoints(int index) {
        return result.GetPoints(index);
      }
      public Builder SetPoints(int index, global::Protocol.WayPointCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.points_[index] = value;
        return this;
      }
      public Builder SetPoints(int index, global::Protocol.WayPointCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.points_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddPoints(global::Protocol.WayPointCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.points_.Add(value);
        return this;
      }
      public Builder AddPoints(global::Protocol.WayPointCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.points_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangePoints(scg::IEnumerable<global::Protocol.WayPointCfg> values) {
        PrepareBuilder();
        result.points_.Add(values);
        return this;
      }
      public Builder ClearPoints() {
        PrepareBuilder();
        result.points_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.WayLineCfg> Lines {
        get { return PrepareBuilder().lines_; }
      }
      public int LinesCount {
        get { return result.LinesCount; }
      }
      public global::Protocol.WayLineCfg GetLines(int index) {
        return result.GetLines(index);
      }
      public Builder SetLines(int index, global::Protocol.WayLineCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.lines_[index] = value;
        return this;
      }
      public Builder SetLines(int index, global::Protocol.WayLineCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.lines_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddLines(global::Protocol.WayLineCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.lines_.Add(value);
        return this;
      }
      public Builder AddLines(global::Protocol.WayLineCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.lines_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeLines(scg::IEnumerable<global::Protocol.WayLineCfg> values) {
        PrepareBuilder();
        result.lines_.Add(values);
        return this;
      }
      public Builder ClearLines() {
        PrepareBuilder();
        result.lines_.Clear();
        return this;
      }
    }
    static WayMapCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class WayPointCfg : pb::GeneratedMessage<WayPointCfg, WayPointCfg.Builder> {
    public WayPointCfg() { }
    private static readonly WayPointCfg defaultInstance = new WayPointCfg().MakeReadOnly();
    private static readonly string[] _wayPointCfgFieldNames = new string[] { "forward", "id", "line_count", "mapId", "maxStandTime", "minStandTime", "need_offset", "offset_value", "pass_line_time", "position", "type" };
    private static readonly uint[] _wayPointCfgFieldTags = new uint[] { 34, 8, 64, 16, 53, 45, 80, 93, 77, 26, 56 };
    public static WayPointCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override WayPointCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override WayPointCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_WayPointCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<WayPointCfg, WayPointCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_WayPointCfg__FieldAccessorTable; }
    }
    
    public const int IdFieldNumber = 1;
    private bool hasId;
    private uint id_;
    public bool HasId {
      get { return hasId; }
    }
    [global::System.CLSCompliant(false)]
    public uint Id {
      get { return id_; }
      set { hasId = true;
        id_ = value;}
    }
    
    public const int MapIdFieldNumber = 2;
    private bool hasMapId;
    private uint mapId_;
    public bool HasMapId {
      get { return hasMapId; }
    }
    [global::System.CLSCompliant(false)]
    public uint MapId {
      get { return mapId_; }
      set { hasMapId = true;
        mapId_ = value;}
    }
    
    public const int PositionFieldNumber = 3;
    private bool hasPosition;
    private global::Protocol.Float3 position_;
    public bool HasPosition {
      get { return hasPosition; }
    }
    public global::Protocol.Float3 Position {
      get { return position_; }
      set { hasPosition = true;
        position_ = value;}
    }
    public void MergePosition(global::Protocol.Float3 value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasPosition &&
        position_ != global::Protocol.Float3.DefaultInstance) {
        position_.MergeFrom(value, isFull);
      } else {
        position_ = value;
      }
    }
    
    public const int ForwardFieldNumber = 4;
    private bool hasForward;
    private global::Protocol.Float3 forward_;
    public bool HasForward {
      get { return hasForward; }
    }
    public global::Protocol.Float3 Forward {
      get { return forward_; }
      set { hasForward = true;
        forward_ = value;}
    }
    public void MergeForward(global::Protocol.Float3 value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasForward &&
        forward_ != global::Protocol.Float3.DefaultInstance) {
        forward_.MergeFrom(value, isFull);
      } else {
        forward_ = value;
      }
    }
    
    public const int MinStandTimeFieldNumber = 5;
    private bool hasMinStandTime;
    private bool isMinStandTimeChanged = true;
    private float minStandTime_;
    public bool HasMinStandTime {
      get { return hasMinStandTime; }
    }
    public float MinStandTime {
      get { return minStandTime_; }
      set { hasMinStandTime = true;
        isMinStandTimeChanged = true;
        minStandTime_ = value;}
    }
    
    public const int MaxStandTimeFieldNumber = 6;
    private bool hasMaxStandTime;
    private bool isMaxStandTimeChanged = true;
    private float maxStandTime_;
    public bool HasMaxStandTime {
      get { return hasMaxStandTime; }
    }
    public float MaxStandTime {
      get { return maxStandTime_; }
      set { hasMaxStandTime = true;
        isMaxStandTimeChanged = true;
        maxStandTime_ = value;}
    }
    
    public const int TypeFieldNumber = 7;
    private bool hasType;
    private bool isTypeChanged = true;
    private uint type_;
    public bool HasType {
      get { return hasType; }
    }
    [global::System.CLSCompliant(false)]
    public uint Type {
      get { return type_; }
      set { hasType = true;
        isTypeChanged = true;
        type_ = value;}
    }
    
    public const int LineCountFieldNumber = 8;
    private bool hasLineCount;
    private bool isLineCountChanged = true;
    private uint lineCount_;
    public bool HasLineCount {
      get { return hasLineCount; }
    }
    [global::System.CLSCompliant(false)]
    public uint LineCount {
      get { return lineCount_; }
      set { hasLineCount = true;
        isLineCountChanged = true;
        lineCount_ = value;}
    }
    
    public const int PassLineTimeFieldNumber = 9;
    private bool hasPassLineTime;
    private bool isPassLineTimeChanged = true;
    private float passLineTime_;
    public bool HasPassLineTime {
      get { return hasPassLineTime; }
    }
    public float PassLineTime {
      get { return passLineTime_; }
      set { hasPassLineTime = true;
        isPassLineTimeChanged = true;
        passLineTime_ = value;}
    }
    
    public const int NeedOffsetFieldNumber = 10;
    private bool hasNeedOffset;
    private bool isNeedOffsetChanged = true;
    private bool needOffset_;
    public bool HasNeedOffset {
      get { return hasNeedOffset; }
    }
    public bool NeedOffset {
      get { return needOffset_; }
      set { hasNeedOffset = true;
        isNeedOffsetChanged = true;
        needOffset_ = value;}
    }
    
    public const int OffsetValueFieldNumber = 11;
    private bool hasOffsetValue;
    private bool isOffsetValueChanged = true;
    private float offsetValue_;
    public bool HasOffsetValue {
      get { return hasOffsetValue; }
    }
    public float OffsetValue {
      get { return offsetValue_; }
      set { hasOffsetValue = true;
        isOffsetValueChanged = true;
        offsetValue_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (!hasId) return false;
        if (!hasMapId) return false;
        if (!hasPosition) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _wayPointCfgFieldNames;
      if (hasId) {
        output.WriteUInt32(1, field_names[1], Id);
      }
      if (hasMapId) {
        output.WriteUInt32(2, field_names[3], MapId);
      }
      if (hasPosition) {
        output.WriteMessage(3, field_names[9], Position);
      }
      if (hasForward) {
        output.WriteMessage(4, field_names[0], Forward);
      }
      if (hasMinStandTime) {
        output.WriteFloat(5, field_names[5], MinStandTime);
      }
      if (hasMaxStandTime) {
        output.WriteFloat(6, field_names[4], MaxStandTime);
      }
      if (hasType) {
        output.WriteUInt32(7, field_names[10], Type);
      }
      if (hasLineCount) {
        output.WriteUInt32(8, field_names[2], LineCount);
      }
      if (hasPassLineTime) {
        output.WriteFloat(9, field_names[8], PassLineTime);
      }
      if (hasNeedOffset) {
        output.WriteBool(10, field_names[6], NeedOffset);
      }
      if (hasOffsetValue) {
        output.WriteFloat(11, field_names[7], OffsetValue);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasId) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, Id);
      }
      if (hasMapId) {
        size += pb::CodedOutputStream.ComputeUInt32Size(2, MapId);
      }
      if (hasPosition) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, Position);
      }
      if (hasForward) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, Forward);
      }
      if (hasMinStandTime) {
        size += pb::CodedOutputStream.ComputeFloatSize(5, MinStandTime);
      }
      if (hasMaxStandTime) {
        size += pb::CodedOutputStream.ComputeFloatSize(6, MaxStandTime);
      }
      if (hasType) {
        size += pb::CodedOutputStream.ComputeUInt32Size(7, Type);
      }
      if (hasLineCount) {
        size += pb::CodedOutputStream.ComputeUInt32Size(8, LineCount);
      }
      if (hasPassLineTime) {
        size += pb::CodedOutputStream.ComputeFloatSize(9, PassLineTime);
      }
      if (hasNeedOffset) {
        size += pb::CodedOutputStream.ComputeBoolSize(10, NeedOffset);
      }
      if (hasOffsetValue) {
        size += pb::CodedOutputStream.ComputeFloatSize(11, OffsetValue);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public WayPointCfg CommitChange() {
      WayPointCfg other = new WayPointCfg();
      bool isChange = false;
      other.Id = Id;
      other.MapId = MapId;
      
      var Positioncommit = Position?.CommitChange();
      if(Positioncommit!=null)
      {
          isChange = true;
          other.Position = Positioncommit;
      }
      
      var Forwardcommit = Forward?.CommitChange();
      if(Forwardcommit!=null)
      {
          isChange = true;
          other.Forward = Forwardcommit;
      }
      if (isMinStandTimeChanged) {
        isChange = true;
        other.MinStandTime = MinStandTime;
        isMinStandTimeChanged = false;
      }
      if (isMaxStandTimeChanged) {
        isChange = true;
        other.MaxStandTime = MaxStandTime;
        isMaxStandTimeChanged = false;
      }
      if (isTypeChanged) {
        isChange = true;
        other.Type = Type;
        isTypeChanged = false;
      }
      if (isLineCountChanged) {
        isChange = true;
        other.LineCount = LineCount;
        isLineCountChanged = false;
      }
      if (isPassLineTimeChanged) {
        isChange = true;
        other.PassLineTime = PassLineTime;
        isPassLineTimeChanged = false;
      }
      if (isNeedOffsetChanged) {
        isChange = true;
        other.NeedOffset = NeedOffset;
        isNeedOffsetChanged = false;
      }
      if (isOffsetValueChanged) {
        isChange = true;
        other.OffsetValue = OffsetValue;
        isOffsetValueChanged = false;
      }
      return isChange?other:null;
    }
    
    public void MergeFrom(WayPointCfg other, bool isFull = false) {
      if (other == global::Protocol.WayPointCfg.DefaultInstance) return;
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasMapId) {
        MapId = other.MapId;
      }
      
      if (other.HasPosition)
      {
        MergePosition(other.Position, isFull);
      }
      
      if (other.HasForward)
      {
        MergeForward(other.Forward, isFull);
      }
      if (other.HasMinStandTime) {
        MinStandTime = other.MinStandTime;
      }
      if (other.HasMaxStandTime) {
        MaxStandTime = other.MaxStandTime;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasLineCount) {
        LineCount = other.LineCount;
      }
      if (other.HasPassLineTime) {
        PassLineTime = other.PassLineTime;
      }
      if (other.HasNeedOffset) {
        NeedOffset = other.NeedOffset;
      }
      if (other.HasOffsetValue) {
        OffsetValue = other.OffsetValue;
      }
    }
    
    public static WayPointCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static WayPointCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static WayPointCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static WayPointCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static WayPointCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static WayPointCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static WayPointCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static WayPointCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static WayPointCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static WayPointCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private WayPointCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(WayPointCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<WayPointCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(WayPointCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private WayPointCfg result;
      
      private WayPointCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          WayPointCfg original = result;
          result = new WayPointCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override WayPointCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.WayPointCfg.Descriptor; }
      }
      
      public override WayPointCfg DefaultInstanceForType {
        get { return global::Protocol.WayPointCfg.DefaultInstance; }
      }
      
      public override WayPointCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is WayPointCfg) {
          return MergeFrom((WayPointCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(WayPointCfg other) {
        if (other == global::Protocol.WayPointCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasId) {
          Id = other.Id;
        }
        if (other.HasMapId) {
          MapId = other.MapId;
        }
        if (other.HasPosition) {
          MergePosition(other.Position);
        }
        if (other.HasForward) {
          MergeForward(other.Forward);
        }
        if (other.HasMinStandTime) {
          MinStandTime = other.MinStandTime;
        }
        if (other.HasMaxStandTime) {
          MaxStandTime = other.MaxStandTime;
        }
        if (other.HasType) {
          Type = other.Type;
        }
        if (other.HasLineCount) {
          LineCount = other.LineCount;
        }
        if (other.HasPassLineTime) {
          PassLineTime = other.PassLineTime;
        }
        if (other.HasNeedOffset) {
          NeedOffset = other.NeedOffset;
        }
        if (other.HasOffsetValue) {
          OffsetValue = other.OffsetValue;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_wayPointCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _wayPointCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasId = input.ReadUInt32(ref result.id_);
              break;
            }
            case 16: {
              result.hasMapId = input.ReadUInt32(ref result.mapId_);
              break;
            }
            case 26: {
              global::Protocol.Float3.Builder subBuilder = global::Protocol.Float3.CreateBuilder();
              if (result.hasPosition) {
                subBuilder.MergeFrom(Position);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Position = subBuilder.BuildPartial();
              break;
            }
            case 34: {
              global::Protocol.Float3.Builder subBuilder = global::Protocol.Float3.CreateBuilder();
              if (result.hasForward) {
                subBuilder.MergeFrom(Forward);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Forward = subBuilder.BuildPartial();
              break;
            }
            case 45: {
              result.hasMinStandTime = input.ReadFloat(ref result.minStandTime_);
              break;
            }
            case 53: {
              result.hasMaxStandTime = input.ReadFloat(ref result.maxStandTime_);
              break;
            }
            case 56: {
              result.hasType = input.ReadUInt32(ref result.type_);
              break;
            }
            case 64: {
              result.hasLineCount = input.ReadUInt32(ref result.lineCount_);
              break;
            }
            case 77: {
              result.hasPassLineTime = input.ReadFloat(ref result.passLineTime_);
              break;
            }
            case 80: {
              result.hasNeedOffset = input.ReadBool(ref result.needOffset_);
              break;
            }
            case 93: {
              result.hasOffsetValue = input.ReadFloat(ref result.offsetValue_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasId {
        get { return result.hasId; }
      }
      [global::System.CLSCompliant(false)]
      public uint Id {
        get { return result.Id; }
        set { SetId(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetId(uint value) {
        PrepareBuilder();
        result.hasId = true;
        result.id_ = value;
        return this;
      }
      public Builder ClearId() {
        PrepareBuilder();
        result.hasId = false;
        result.id_ = 0;
        return this;
      }
      
      public bool HasMapId {
        get { return result.hasMapId; }
      }
      [global::System.CLSCompliant(false)]
      public uint MapId {
        get { return result.MapId; }
        set { SetMapId(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetMapId(uint value) {
        PrepareBuilder();
        result.hasMapId = true;
        result.mapId_ = value;
        return this;
      }
      public Builder ClearMapId() {
        PrepareBuilder();
        result.hasMapId = false;
        result.mapId_ = 0;
        return this;
      }
      
      public bool HasPosition {
       get { return result.hasPosition; }
      }
      public global::Protocol.Float3 Position {
        get { return result.Position; }
        set { SetPosition(value); }
      }
      public Builder SetPosition(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPosition = true;
        result.position_ = value;
        return this;
      }
      public Builder SetPosition(global::Protocol.Float3.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasPosition = true;
        result.position_ = builderForValue.Build();
        return this;
      }
      public Builder MergePosition(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasPosition &&
            result.position_ != global::Protocol.Float3.DefaultInstance) {
            result.position_ = global::Protocol.Float3.CreateBuilder(result.position_).MergeFrom(value).BuildPartial();
        } else {
          result.position_ = value;
          result.hasPosition = true;
        }
        return this;
      }
      public Builder ClearPosition() {
        PrepareBuilder();
        result.hasPosition = false;
        result.position_ = null;
        return this;
      }
      
      public bool HasForward {
       get { return result.hasForward; }
      }
      public global::Protocol.Float3 Forward {
        get { return result.Forward; }
        set { SetForward(value); }
      }
      public Builder SetForward(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasForward = true;
        result.forward_ = value;
        return this;
      }
      public Builder SetForward(global::Protocol.Float3.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasForward = true;
        result.forward_ = builderForValue.Build();
        return this;
      }
      public Builder MergeForward(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasForward &&
            result.forward_ != global::Protocol.Float3.DefaultInstance) {
            result.forward_ = global::Protocol.Float3.CreateBuilder(result.forward_).MergeFrom(value).BuildPartial();
        } else {
          result.forward_ = value;
          result.hasForward = true;
        }
        return this;
      }
      public Builder ClearForward() {
        PrepareBuilder();
        result.hasForward = false;
        result.forward_ = null;
        return this;
      }
      
      public bool HasMinStandTime {
        get { return result.hasMinStandTime; }
      }
      public float MinStandTime {
        get { return result.MinStandTime; }
        set { SetMinStandTime(value); }
      }
      public Builder SetMinStandTime(float value) {
        PrepareBuilder();
        result.hasMinStandTime = true;
        result.minStandTime_ = value;
        return this;
      }
      public Builder ClearMinStandTime() {
        PrepareBuilder();
        result.hasMinStandTime = false;
        result.minStandTime_ = 0F;
        return this;
      }
      
      public bool HasMaxStandTime {
        get { return result.hasMaxStandTime; }
      }
      public float MaxStandTime {
        get { return result.MaxStandTime; }
        set { SetMaxStandTime(value); }
      }
      public Builder SetMaxStandTime(float value) {
        PrepareBuilder();
        result.hasMaxStandTime = true;
        result.maxStandTime_ = value;
        return this;
      }
      public Builder ClearMaxStandTime() {
        PrepareBuilder();
        result.hasMaxStandTime = false;
        result.maxStandTime_ = 0F;
        return this;
      }
      
      public bool HasType {
        get { return result.hasType; }
      }
      [global::System.CLSCompliant(false)]
      public uint Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetType(uint value) {
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = 0;
        return this;
      }
      
      public bool HasLineCount {
        get { return result.hasLineCount; }
      }
      [global::System.CLSCompliant(false)]
      public uint LineCount {
        get { return result.LineCount; }
        set { SetLineCount(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetLineCount(uint value) {
        PrepareBuilder();
        result.hasLineCount = true;
        result.lineCount_ = value;
        return this;
      }
      public Builder ClearLineCount() {
        PrepareBuilder();
        result.hasLineCount = false;
        result.lineCount_ = 0;
        return this;
      }
      
      public bool HasPassLineTime {
        get { return result.hasPassLineTime; }
      }
      public float PassLineTime {
        get { return result.PassLineTime; }
        set { SetPassLineTime(value); }
      }
      public Builder SetPassLineTime(float value) {
        PrepareBuilder();
        result.hasPassLineTime = true;
        result.passLineTime_ = value;
        return this;
      }
      public Builder ClearPassLineTime() {
        PrepareBuilder();
        result.hasPassLineTime = false;
        result.passLineTime_ = 0F;
        return this;
      }
      
      public bool HasNeedOffset {
        get { return result.hasNeedOffset; }
      }
      public bool NeedOffset {
        get { return result.NeedOffset; }
        set { SetNeedOffset(value); }
      }
      public Builder SetNeedOffset(bool value) {
        PrepareBuilder();
        result.hasNeedOffset = true;
        result.needOffset_ = value;
        return this;
      }
      public Builder ClearNeedOffset() {
        PrepareBuilder();
        result.hasNeedOffset = false;
        result.needOffset_ = false;
        return this;
      }
      
      public bool HasOffsetValue {
        get { return result.hasOffsetValue; }
      }
      public float OffsetValue {
        get { return result.OffsetValue; }
        set { SetOffsetValue(value); }
      }
      public Builder SetOffsetValue(float value) {
        PrepareBuilder();
        result.hasOffsetValue = true;
        result.offsetValue_ = value;
        return this;
      }
      public Builder ClearOffsetValue() {
        PrepareBuilder();
        result.hasOffsetValue = false;
        result.offsetValue_ = 0F;
        return this;
      }
    }
    static WayPointCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class WayLineCfg : pb::GeneratedMessage<WayLineCfg, WayLineCfg.Builder> {
    public WayLineCfg() { }
    private static readonly WayLineCfg defaultInstance = new WayLineCfg().MakeReadOnly();
    private static readonly string[] _wayLineCfgFieldNames = new string[] { "cost", "head", "is_one_way", "last" };
    private static readonly uint[] _wayLineCfgFieldTags = new uint[] { 29, 10, 32, 18 };
    public static WayLineCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override WayLineCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override WayLineCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_WayLineCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<WayLineCfg, WayLineCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_WayLineCfg__FieldAccessorTable; }
    }
    
    public const int HeadFieldNumber = 1;
    private bool hasHead;
    private global::Protocol.WayPointCfg head_;
    public bool HasHead {
      get { return hasHead; }
    }
    public global::Protocol.WayPointCfg Head {
      get { return head_; }
      set { hasHead = true;
        head_ = value;}
    }
    public void MergeHead(global::Protocol.WayPointCfg value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasHead &&
        head_ != global::Protocol.WayPointCfg.DefaultInstance) {
        head_.MergeFrom(value, isFull);
      } else {
        head_ = value;
      }
    }
    
    public const int LastFieldNumber = 2;
    private bool hasLast;
    private global::Protocol.WayPointCfg last_;
    public bool HasLast {
      get { return hasLast; }
    }
    public global::Protocol.WayPointCfg Last {
      get { return last_; }
      set { hasLast = true;
        last_ = value;}
    }
    public void MergeLast(global::Protocol.WayPointCfg value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasLast &&
        last_ != global::Protocol.WayPointCfg.DefaultInstance) {
        last_.MergeFrom(value, isFull);
      } else {
        last_ = value;
      }
    }
    
    public const int CostFieldNumber = 3;
    private bool hasCost;
    private float cost_;
    public bool HasCost {
      get { return hasCost; }
    }
    public float Cost {
      get { return cost_; }
      set { hasCost = true;
        cost_ = value;}
    }
    
    public const int IsOneWayFieldNumber = 4;
    private bool hasIsOneWay;
    private bool isOneWay_;
    public bool HasIsOneWay {
      get { return hasIsOneWay; }
    }
    public bool IsOneWay {
      get { return isOneWay_; }
      set { hasIsOneWay = true;
        isOneWay_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (!hasHead) return false;
        if (!hasLast) return false;
        if (!hasCost) return false;
        if (!hasIsOneWay) return false;
        if (!Head.IsInitialized) return false;
        if (!Last.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _wayLineCfgFieldNames;
      if (hasHead) {
        output.WriteMessage(1, field_names[1], Head);
      }
      if (hasLast) {
        output.WriteMessage(2, field_names[3], Last);
      }
      if (hasCost) {
        output.WriteFloat(3, field_names[0], Cost);
      }
      if (hasIsOneWay) {
        output.WriteBool(4, field_names[2], IsOneWay);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasHead) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Head);
      }
      if (hasLast) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, Last);
      }
      if (hasCost) {
        size += pb::CodedOutputStream.ComputeFloatSize(3, Cost);
      }
      if (hasIsOneWay) {
        size += pb::CodedOutputStream.ComputeBoolSize(4, IsOneWay);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public WayLineCfg CommitChange() {
      WayLineCfg other = new WayLineCfg();
      bool isChange = false;
      
      var Headcommit = Head?.CommitChange();
      if(Headcommit!=null)
      {
          isChange = true;
          other.Head = Headcommit;
      }
      
      var Lastcommit = Last?.CommitChange();
      if(Lastcommit!=null)
      {
          isChange = true;
          other.Last = Lastcommit;
      }
      other.Cost = Cost;
      other.IsOneWay = IsOneWay;
      return isChange?other:null;
    }
    
    public void MergeFrom(WayLineCfg other, bool isFull = false) {
      if (other == global::Protocol.WayLineCfg.DefaultInstance) return;
      
      if (other.HasHead)
      {
        MergeHead(other.Head, isFull);
      }
      
      if (other.HasLast)
      {
        MergeLast(other.Last, isFull);
      }
      if (other.HasCost) {
        Cost = other.Cost;
      }
      if (other.HasIsOneWay) {
        IsOneWay = other.IsOneWay;
      }
    }
    
    public static WayLineCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static WayLineCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static WayLineCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static WayLineCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static WayLineCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static WayLineCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static WayLineCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static WayLineCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static WayLineCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static WayLineCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private WayLineCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(WayLineCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<WayLineCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(WayLineCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private WayLineCfg result;
      
      private WayLineCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          WayLineCfg original = result;
          result = new WayLineCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override WayLineCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.WayLineCfg.Descriptor; }
      }
      
      public override WayLineCfg DefaultInstanceForType {
        get { return global::Protocol.WayLineCfg.DefaultInstance; }
      }
      
      public override WayLineCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is WayLineCfg) {
          return MergeFrom((WayLineCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(WayLineCfg other) {
        if (other == global::Protocol.WayLineCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasHead) {
          MergeHead(other.Head);
        }
        if (other.HasLast) {
          MergeLast(other.Last);
        }
        if (other.HasCost) {
          Cost = other.Cost;
        }
        if (other.HasIsOneWay) {
          IsOneWay = other.IsOneWay;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_wayLineCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _wayLineCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Protocol.WayPointCfg.Builder subBuilder = global::Protocol.WayPointCfg.CreateBuilder();
              if (result.hasHead) {
                subBuilder.MergeFrom(Head);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Head = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::Protocol.WayPointCfg.Builder subBuilder = global::Protocol.WayPointCfg.CreateBuilder();
              if (result.hasLast) {
                subBuilder.MergeFrom(Last);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Last = subBuilder.BuildPartial();
              break;
            }
            case 29: {
              result.hasCost = input.ReadFloat(ref result.cost_);
              break;
            }
            case 32: {
              result.hasIsOneWay = input.ReadBool(ref result.isOneWay_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasHead {
       get { return result.hasHead; }
      }
      public global::Protocol.WayPointCfg Head {
        get { return result.Head; }
        set { SetHead(value); }
      }
      public Builder SetHead(global::Protocol.WayPointCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHead = true;
        result.head_ = value;
        return this;
      }
      public Builder SetHead(global::Protocol.WayPointCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasHead = true;
        result.head_ = builderForValue.Build();
        return this;
      }
      public Builder MergeHead(global::Protocol.WayPointCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasHead &&
            result.head_ != global::Protocol.WayPointCfg.DefaultInstance) {
            result.head_ = global::Protocol.WayPointCfg.CreateBuilder(result.head_).MergeFrom(value).BuildPartial();
        } else {
          result.head_ = value;
          result.hasHead = true;
        }
        return this;
      }
      public Builder ClearHead() {
        PrepareBuilder();
        result.hasHead = false;
        result.head_ = null;
        return this;
      }
      
      public bool HasLast {
       get { return result.hasLast; }
      }
      public global::Protocol.WayPointCfg Last {
        get { return result.Last; }
        set { SetLast(value); }
      }
      public Builder SetLast(global::Protocol.WayPointCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLast = true;
        result.last_ = value;
        return this;
      }
      public Builder SetLast(global::Protocol.WayPointCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasLast = true;
        result.last_ = builderForValue.Build();
        return this;
      }
      public Builder MergeLast(global::Protocol.WayPointCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasLast &&
            result.last_ != global::Protocol.WayPointCfg.DefaultInstance) {
            result.last_ = global::Protocol.WayPointCfg.CreateBuilder(result.last_).MergeFrom(value).BuildPartial();
        } else {
          result.last_ = value;
          result.hasLast = true;
        }
        return this;
      }
      public Builder ClearLast() {
        PrepareBuilder();
        result.hasLast = false;
        result.last_ = null;
        return this;
      }
      
      public bool HasCost {
        get { return result.hasCost; }
      }
      public float Cost {
        get { return result.Cost; }
        set { SetCost(value); }
      }
      public Builder SetCost(float value) {
        PrepareBuilder();
        result.hasCost = true;
        result.cost_ = value;
        return this;
      }
      public Builder ClearCost() {
        PrepareBuilder();
        result.hasCost = false;
        result.cost_ = 0F;
        return this;
      }
      
      public bool HasIsOneWay {
        get { return result.hasIsOneWay; }
      }
      public bool IsOneWay {
        get { return result.IsOneWay; }
        set { SetIsOneWay(value); }
      }
      public Builder SetIsOneWay(bool value) {
        PrepareBuilder();
        result.hasIsOneWay = true;
        result.isOneWay_ = value;
        return this;
      }
      public Builder ClearIsOneWay() {
        PrepareBuilder();
        result.hasIsOneWay = false;
        result.isOneWay_ = false;
        return this;
      }
    }
    static WayLineCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Float3 : pb::GeneratedMessage<Float3, Float3.Builder> {
    public Float3() { }
    private static readonly Float3 defaultInstance = new Float3().MakeReadOnly();
    private static readonly string[] _float3FieldNames = new string[] { "x", "y", "z" };
    private static readonly uint[] _float3FieldTags = new uint[] { 13, 21, 29 };
    public static Float3 DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Float3 DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Float3 ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_Float3__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Float3, Float3.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_Float3__FieldAccessorTable; }
    }
    
    public const int XFieldNumber = 1;
    private bool hasX;
    private bool isXChanged = true;
    private float x_;
    public bool HasX {
      get { return hasX; }
    }
    public float X {
      get { return x_; }
      set { hasX = true;
        isXChanged = true;
        x_ = value;}
    }
    
    public const int YFieldNumber = 2;
    private bool hasY;
    private bool isYChanged = true;
    private float y_;
    public bool HasY {
      get { return hasY; }
    }
    public float Y {
      get { return y_; }
      set { hasY = true;
        isYChanged = true;
        y_ = value;}
    }
    
    public const int ZFieldNumber = 3;
    private bool hasZ;
    private bool isZChanged = true;
    private float z_;
    public bool HasZ {
      get { return hasZ; }
    }
    public float Z {
      get { return z_; }
      set { hasZ = true;
        isZChanged = true;
        z_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _float3FieldNames;
      if (hasX) {
        output.WriteFloat(1, field_names[0], X);
      }
      if (hasY) {
        output.WriteFloat(2, field_names[1], Y);
      }
      if (hasZ) {
        output.WriteFloat(3, field_names[2], Z);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasX) {
        size += pb::CodedOutputStream.ComputeFloatSize(1, X);
      }
      if (hasY) {
        size += pb::CodedOutputStream.ComputeFloatSize(2, Y);
      }
      if (hasZ) {
        size += pb::CodedOutputStream.ComputeFloatSize(3, Z);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public Float3 CommitChange() {
      Float3 other = new Float3();
      bool isChange = false;
      if (isXChanged) {
        isChange = true;
        other.X = X;
        isXChanged = false;
      }
      if (isYChanged) {
        isChange = true;
        other.Y = Y;
        isYChanged = false;
      }
      if (isZChanged) {
        isChange = true;
        other.Z = Z;
        isZChanged = false;
      }
      return isChange?other:null;
    }
    
    public void MergeFrom(Float3 other, bool isFull = false) {
      if (other == global::Protocol.Float3.DefaultInstance) return;
      if (other.HasX) {
        X = other.X;
      }
      if (other.HasY) {
        Y = other.Y;
      }
      if (other.HasZ) {
        Z = other.Z;
      }
    }
    
    public static Float3 ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Float3 ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Float3 ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Float3 ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Float3 ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Float3 ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Float3 ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Float3 ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Float3 ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Float3 ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Float3 MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Float3 prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Float3, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Float3 cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Float3 result;
      
      private Float3 PrepareBuilder() {
        if (resultIsReadOnly) {
          Float3 original = result;
          result = new Float3();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Float3 MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.Float3.Descriptor; }
      }
      
      public override Float3 DefaultInstanceForType {
        get { return global::Protocol.Float3.DefaultInstance; }
      }
      
      public override Float3 BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Float3) {
          return MergeFrom((Float3) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Float3 other) {
        if (other == global::Protocol.Float3.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasX) {
          X = other.X;
        }
        if (other.HasY) {
          Y = other.Y;
        }
        if (other.HasZ) {
          Z = other.Z;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_float3FieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _float3FieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 13: {
              result.hasX = input.ReadFloat(ref result.x_);
              break;
            }
            case 21: {
              result.hasY = input.ReadFloat(ref result.y_);
              break;
            }
            case 29: {
              result.hasZ = input.ReadFloat(ref result.z_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasX {
        get { return result.hasX; }
      }
      public float X {
        get { return result.X; }
        set { SetX(value); }
      }
      public Builder SetX(float value) {
        PrepareBuilder();
        result.hasX = true;
        result.x_ = value;
        return this;
      }
      public Builder ClearX() {
        PrepareBuilder();
        result.hasX = false;
        result.x_ = 0F;
        return this;
      }
      
      public bool HasY {
        get { return result.hasY; }
      }
      public float Y {
        get { return result.Y; }
        set { SetY(value); }
      }
      public Builder SetY(float value) {
        PrepareBuilder();
        result.hasY = true;
        result.y_ = value;
        return this;
      }
      public Builder ClearY() {
        PrepareBuilder();
        result.hasY = false;
        result.y_ = 0F;
        return this;
      }
      
      public bool HasZ {
        get { return result.hasZ; }
      }
      public float Z {
        get { return result.Z; }
        set { SetZ(value); }
      }
      public Builder SetZ(float value) {
        PrepareBuilder();
        result.hasZ = true;
        result.z_ = value;
        return this;
      }
      public Builder ClearZ() {
        PrepareBuilder();
        result.hasZ = false;
        result.z_ = 0F;
        return this;
      }
    }
    static Float3() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
